use crate::generate::*;
use crate::stub_type::ImportRef;
use itertools::Itertools;
use std::{
    any::TypeId,
    collections::{BTreeMap, BTreeSet},
    fmt,
};

/// Type info for a Python (sub-)module. This corresponds to a single `*.pyi` file.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Module {
    pub doc: String,
    pub class: BTreeMap<TypeId, ClassDef>,
    pub enum_: BTreeMap<TypeId, EnumDef>,
    pub function: BTreeMap<&'static str, Vec<FunctionDef>>,
    pub variables: BTreeMap<&'static str, VariableDef>,
    pub name: String,
    pub default_module_name: String,
    /// Direct submodules of this module.
    pub submodules: BTreeSet<String>,
}

impl Import for Module {
    fn import(&self) -> HashSet<ImportRef> {
        let mut imports = HashSet::new();
        for class in self.class.values() {
            imports.extend(class.import());
        }
        for enum_ in self.enum_.values() {
            imports.extend(enum_.import());
        }
        for function in self.function.values().flatten() {
            imports.extend(function.import());
        }
        imports
    }
}

impl fmt::Display for Module {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "# This file is automatically generated by pyo3_stub_gen")?;
        writeln!(f, "# ruff: noqa: E501, F401")?;
        if !self.doc.is_empty() {
            docstring::write_docstring(f, &self.doc, "")?;
        }
        writeln!(f)?;
        let mut imports = self.import();
        let any_overloaded = self.function.values().any(|functions| functions.len() > 1);
        if any_overloaded {
            imports.insert("typing".into());
        }

        // To gather `from submod import A, B, C` style imports
        let mut type_ref_grouped: BTreeMap<String, Vec<String>> = BTreeMap::new();
        for import_ref in imports.into_iter().sorted() {
            match import_ref {
                ImportRef::Module(module_ref) => {
                    let name = module_ref.get().unwrap_or(&self.default_module_name);
                    if name != self.name {
                        writeln!(f, "import {name}")?;
                    }
                }
                ImportRef::Type(type_ref) => {
                    let module_name = type_ref.module.get().unwrap_or(&self.default_module_name);
                    if module_name != self.name {
                        type_ref_grouped
                            .entry(module_name.to_string())
                            .or_default()
                            .push(type_ref.name);
                    }
                }
            }
        }
        for (module_name, type_names) in type_ref_grouped {
            let mut sorted_type_names = type_names.clone();
            sorted_type_names.sort();
            writeln!(
                f,
                "from {} import {}",
                module_name,
                sorted_type_names.join(", ")
            )?;
        }
        for submod in &self.submodules {
            writeln!(f, "from . import {submod}")?;
        }
        writeln!(f)?;

        for var in self.variables.values() {
            writeln!(f, "{var}")?;
        }
        for class in self.class.values().sorted_by_key(|class| class.name) {
            write!(f, "{class}")?;
        }
        for enum_ in self.enum_.values().sorted_by_key(|class| class.name) {
            write!(f, "{enum_}")?;
        }
        for functions in self.function.values() {
            let overloaded = functions.len() > 1;
            for function in functions {
                if overloaded {
                    writeln!(f, "@typing.overload")?;
                }
                write!(f, "{function}")?;
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stub_type::{self_import_strategy, set_self_import_strategy, SelfImportStrategy};
    use crate::TypeInfo;
    use indexmap::IndexMap;
    use std::any::TypeId;

    fn render_new_method_module() -> String {
        let mut class = ClassDef {
            name: "Foo",
            doc: "",
            attrs: Vec::new(),
            getter_setters: IndexMap::new(),
            methods: IndexMap::new(),
            classes: Vec::new(),
            bases: Vec::new(),
            match_args: None,
            subclass: false,
            is_abstract: false,
        };
        class
            .methods
            .entry("__new__".to_string())
            .or_default()
            .push(MethodDef {
                name: "__new__",
                parameters: Parameters::new(),
                r#return: TypeInfo::self_type(),
                doc: "",
                r#type: MethodType::New,
                is_async: false,
                deprecated: None,
                type_ignored: None,
                is_abstract: false,
            });

        let mut module = Module::default();
        module.name = "foo".into();
        module.default_module_name = "foo".into();
        module.class.insert(TypeId::of::<()>(), class);
        module.to_string()
    }

    #[test]
    fn new_method_uses_self_return_type() {
        let original = self_import_strategy();
        set_self_import_strategy(SelfImportStrategy::Typing);
        let rendered = render_new_method_module();
        assert!(
            rendered.contains("from typing import Self"),
            "expected typing import, got:\n{rendered}"
        );
        assert!(
            rendered.contains("def __new__(cls) -> Self"),
            "expected __new__ signature with Self, got:\n{rendered}"
        );
        set_self_import_strategy(original);
    }

    #[test]
    fn new_method_switches_to_typing_extensions_when_configured() {
        let original = self_import_strategy();
        set_self_import_strategy(SelfImportStrategy::TypingExtensions);
        let rendered = render_new_method_module();
        assert!(
            rendered.contains("from typing_extensions import Self"),
            "expected typing_extensions import, got:\n{rendered}"
        );
        set_self_import_strategy(original);
    }
}
